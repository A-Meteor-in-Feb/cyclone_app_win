/****************************************************************

  Generated by Eclipse Cyclone DDS IDL to CXX Translator
  File name: D:\codes\Cyclone_Version_Apps\cyclonev2.1\teleop_side\ControlData.idl
  Source: ControlData.cpp
  Cyclone DDS: v0.11.0

*****************************************************************/
#include "ControlData.hpp"

#include <org/eclipse/cyclonedds/util/ostream_operators.hpp>

namespace ControlData
{
std::ostream& operator<<(std::ostream& os, tele_status const& rhs)
{
  (void) rhs;
  os << "[";
  os << "tele_id: " << rhs.tele_id();
  os << ", online: " << rhs.online();
  os << ", connected: " << rhs.connected();
  os << "]";
  return os;
}

std::ostream& operator<<(std::ostream& os, vehicle_status const& rhs)
{
  (void) rhs;
  os << "[";
  os << "vehicle_id: " << rhs.vehicle_id();
  os << ", online: " << rhs.online();
  os << ", connected: " << rhs.connected();
  os << "]";
  return os;
}

std::ostream& operator<<(std::ostream& os, connection_msg const& rhs)
{
  (void) rhs;
  os << "[";
  os << "tele_id: " << rhs.tele_id();
  os << ", vehicle_id: " << rhs.vehicle_id();
  os << "]";
  return os;
}

std::ostream& operator<<(std::ostream& os, disconnection_msg const& rhs)
{
  (void) rhs;
  os << "[";
  os << "msg: " << rhs.msg();
  os << "]";
  return os;
}

std::ostream& operator<<(std::ostream& os, steeringWheel_data const& rhs)
{
  (void) rhs;
  os << "[";
  os << "lX: " << rhs.lX();
  os << ", lY: " << rhs.lY();
  os << ", lRz: " << rhs.lRz();
  os << ", rglSlider_0: " << rhs.rglSlider_0();
  os << ", buttons: " << rhs.buttons();
  os << "]";
  return os;
}

std::ostream& operator<<(std::ostream& os, joyStick_data const& rhs)
{
  (void) rhs;
  os << "[";
  os << "lX: " << rhs.lX();
  os << ", lZ: " << rhs.lZ();
  os << ", lRx: " << rhs.lRx();
  os << ", lRy: " << rhs.lRy();
  os << ", lRz: " << rhs.lRz();
  os << ", buttons: " << rhs.buttons();
  os << ", rglSlider: " << rhs.rglSlider();
  os << "]";
  return os;
}

std::ostream& operator<<(std::ostream& os, streamdeck_buttons_data const& rhs)
{
  (void) rhs;
  os << "[";
  os << "buttons: " << rhs.buttons();
  os << "]";
  return os;
}

std::ostream& operator<<(std::ostream& os, statistic_data const& rhs)
{
  (void) rhs;
  os << "[";
  os << "height: " << rhs.height();
  os << ", depth: " << rhs.depth();
  os << ", auto_flag: " << rhs.auto_flag();
  os << "]";
  return os;
}

std::ostream& operator<<(std::ostream& os, imu_data const& rhs)
{
  (void) rhs;
  os << "[";
  os << "acc: " << rhs.acc();
  os << ", gyro: " << rhs.gyro();
  os << ", angle: " << rhs.angle();
  os << ", mag: " << rhs.mag();
  os << "]";
  return os;
}

} //namespace ControlData

namespace org{
namespace eclipse{
namespace cyclonedds{
namespace core{
namespace cdr{

template<>
const propvec &get_type_props<::ControlData::tele_status>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::tele_id
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<bool>(), extensibility::ext_final, false));  //::online
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<bool>(), extensibility::ext_final, false));  //::connected

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
const propvec &get_type_props<::ControlData::vehicle_status>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::vehicle_id
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<bool>(), extensibility::ext_final, false));  //::online
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<bool>(), extensibility::ext_final, false));  //::connected

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
const propvec &get_type_props<::ControlData::connection_msg>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::tele_id
  props.push_back(entity_properties_t(1, 1, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::vehicle_id

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
const propvec &get_type_props<::ControlData::disconnection_msg>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::msg

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
const propvec &get_type_props<::ControlData::steeringWheel_data>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<int32_t>(), extensibility::ext_final, false));  //::lX
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<int32_t>(), extensibility::ext_final, false));  //::lY
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<int32_t>(), extensibility::ext_final, false));  //::lRz
  props.push_back(entity_properties_t(1, 3, false, get_bit_bound<int32_t>(), extensibility::ext_final, false));  //::rglSlider_0
  props.push_back(entity_properties_t(1, 4, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::buttons

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
const propvec &get_type_props<::ControlData::joyStick_data>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<int32_t>(), extensibility::ext_final, false));  //::lX
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<int32_t>(), extensibility::ext_final, false));  //::lZ
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<int32_t>(), extensibility::ext_final, false));  //::lRx
  props.push_back(entity_properties_t(1, 3, false, get_bit_bound<int32_t>(), extensibility::ext_final, false));  //::lRy
  props.push_back(entity_properties_t(1, 4, false, get_bit_bound<int32_t>(), extensibility::ext_final, false));  //::lRz
  props.push_back(entity_properties_t(1, 5, false, get_bit_bound<uint32_t>(), extensibility::ext_final, false));  //::buttons
  props.push_back(entity_properties_t(1, 6, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::rglSlider

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
const propvec &get_type_props<::ControlData::streamdeck_buttons_data>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<int16_t>(), extensibility::ext_final, false));  //::buttons

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
const propvec &get_type_props<::ControlData::statistic_data>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::height
  props.push_back(entity_properties_t(1, 1, false, get_bit_bound<double>(), extensibility::ext_final, false));  //::depth
  props.push_back(entity_properties_t(1, 2, false, get_bit_bound<int16_t>(), extensibility::ext_final, false));  //::auto_flag

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

template<>
const propvec &get_type_props<::ControlData::imu_data>() {
  static std::mutex mtx;
  static propvec props;
  static std::atomic_bool initialized {false};
  key_endpoint keylist;
  if (initialized.load(std::memory_order_relaxed))
    return props;
  std::lock_guard<std::mutex> lock(mtx);
  if (initialized.load(std::memory_order_relaxed))
    return props;
  props.clear();

  props.push_back(entity_properties_t(0, 0, false, bit_bound::bb_unset, extensibility::ext_final));  //root
  props.push_back(entity_properties_t(1, 0, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::acc
  props.push_back(entity_properties_t(1, 1, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::gyro
  props.push_back(entity_properties_t(1, 2, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::angle
  props.push_back(entity_properties_t(1, 3, false, bit_bound::bb_unset, extensibility::ext_final, false));  //::mag

  entity_properties_t::finish(props, keylist);
  initialized.store(true, std::memory_order_release);
  return props;
}

} //namespace cdr
} //namespace core
} //namespace cyclonedds
} //namespace eclipse
} //namespace org

